#include "cspe_custom/cspe_color.txt"
#include "cspe_custom/cspe_option.txt"

#include "uniformPerFrameConstants.h"
#include "uniformShaderConstants.h"
#include "uniformRenderChunkConstants.h"
#include "uniformEntityConstants.h"

vec4 sfog_color =vec4(0.0);
vec4 sky_far=vec4(0.0);
vec4 skytop_color=vec4(0.0);
vec4 w_light_color=vec4(0.0);
vec4 cloud_color=vec4(0.0);
vec4 cloud_sh_color=vec4(0.0);
vec4 sunmoon_color=vec4(0.0);
vec4 reflect_color=vec4(0.0);

float water_f,reflect_f,fog_f=0.0;
float player_sh_f,block_sh_f=0.0;
float night_f,sunset_f,rain_f =0.0;

float fog_night_f =0.0;
float fog_sunset_f =0.0;
float light_f =1.0;

float f_sh_f,x_sh_f,dark_sh_f,sh_f =0.0;

float side_top_f,side_bot_f,side_y_f,side_x_f,side_z_f,side_xz_f=0.0;

float un_sh_light=0.0;

vec3 side_f =vec3(0.0);

void timeFlag(){

//CSPE 5.0
rain_f =clamp((1.0-pow(FOG_CONTROL.y+0.1,5.0))*2.0,0.0,1.0);

night_f =clamp((0.6-light_f+clamp(0.6-light_f,0.0,1.0))*1.5,0.0,1.0);
sunset_f =clamp((1.0-light_f)*3.0,0.0,clamp(1.0-night_f-rain_f,0.0,1.0));

fog_night_f =pow(clamp(1.0-(FOG_COLOR.r+FOG_COLOR.b)*1.5,0.0,1.0),0.5);
fog_sunset_f =pow(clamp(1.0-(FOG_COLOR.b+FOG_COLOR.g),0.0,clamp(1.0-fog_night_f-rain_f,0.0,1.0)),0.5);

}

void sideFlag(in vec3 w_pos){
side_f=normalize(cross(dFdx(w_pos),dFdy(w_pos)));

side_y_f =clamp(side_f.y,0.0,1.0);
side_x_f =clamp(side_f.x,0.0,1.0);
side_z_f =clamp(side_f.z,0.0,1.0);
side_xz_f =clamp(side_x_f+side_z_f,0.0,1.0);
}

void cspeColor(){
un_sh_light = clamp(1.0-pow(FOG_COLOR.r*1.5,5.0)-fog_sunset_f-fog_night_f,0.0,1.0);

w_light_color = mix(mix(day_color,sunset_color,sunset_f),night_color,night_f);
w_light_color = mix(w_light_color,vec4(vec3(w_light_color.b+night_f*0.5),1.0)*rain_color,rain_f);

skytop_color =mix(mix(sky_day_color,sky_sunset_color,fog_sunset_f),sky_night_color,fog_night_f);
skytop_color = mix(skytop_color,vec4(vec3(skytop_color.r+CURRENT_COLOR.r),1.0)*sky_rain_color,rain_f);

sky_far =mix(mix(skyline_day_color,skyline_sunset_color,fog_sunset_f),skyline_night_color,fog_night_f);
sky_far = mix(sky_far,vec4(vec3(sky_far.r),1.0)*skyline_rain_color,rain_f);

sfog_color =mix(mix(fsky_day_color*0.79,fsky_sunset_color,fog_sunset_f),fsky_night_color,fog_night_f);
sfog_color = mix(sfog_color,vec4(vec3(sfog_color.r),1.0)*fsky_rain_color,rain_f);

cloud_color =mix(mix(cloud_day_color,cloud_sunset_color,fog_sunset_f),cloud_night_color,fog_night_f);
cloud_color = mix(cloud_color,vec4(vec3(cloud_color.r+CURRENT_COLOR.r),1.0)*cloud_rain_color,rain_f);

cloud_sh_color =mix(mix(cloud_day_sh_color,cloud_sunset_sh_color,fog_sunset_f),cloud_night_sh_color,fog_night_f);
cloud_sh_color = mix(cloud_sh_color,vec4(vec3(cloud_sh_color.r),1.0)*cloud_rain_sh_color,rain_f);

sunmoon_color =mix(mix(sun_color,sun_sunset_color,fog_sunset_f),moon_color,fog_night_f);
sunmoon_color.a = 1.0-rain_f;

reflect_color =mix(mix(reflect_day_color,reflect_sunset_color,fog_sunset_f),reflect_night_color,fog_night_f);
reflect_color = mix(reflect_color,vec4(0.0),rain_f);

#ifdef UN_SH_LIGHT
w_light_color*=un_sh_light*0.5+1.0;
#endif
}

float p_sh(vec2 pos, float x1, float y1, float x2, float y2, float focus){
pos*=0.7;
 return min(1.0, max(min(min(pos.x - x1, x2 - pos.x), min(pos.y - y1, y2 - pos.y)), 0.0) / focus);
}


float playerShadowSet(vec3 w_pos,vec3 v_pos){
timeFlag();
vec3 lookvector=v_pos;
lookvector.x*=2.0;
 vec3 pos = lookvector + vec3(0.4, 0.4, 0.4); 
 vec3 dir = vec3(-1.0, (1.25) * 0.31, 0.0);
 float factor = 1.0;
 if (pos.x < 0.2){
  factor = max(0.0, pos.x / 0.4 + 0.5);
 }
pos += dir * pos.x;
 float focus = 0.06-v_pos.y*0.02;
 float footwalk = sin(((w_pos.x - lookvector.x)  + (w_pos.z - lookvector.z))*2.0)*0.3;
float handswalk = sin(((w_pos.x - lookvector.x) + (w_pos.z - lookvector.z))*2.0);
pos.yz -= vec2(0.6, 0.4);
float body = p_sh(pos.yz, -0.48+sunset_f*2.0, -0.25, 0.75+sunset_f*5.0, 0.25, focus);
 float foot = max(p_sh(pos.yz, -1.3 + footwalk*0.4, -0.25, 0.2+sunset_f*4.0, 0.1, focus), p_sh(pos.yz, -1.3 - footwalk*0.4, -0.1, 0.2+sunset_f*4.0, 0.25, focus));
 float hands = max(p_sh(pos.yz, -0.5 + handswalk * 0.1+sunset_f*2.0, -0.5, 0.25+sunset_f*4.0, -0.0, focus), p_sh(pos.yz, -0.5 - handswalk * 0.1+sunset_f*2.0, 0.0, 0.25+sunset_f*4.0, 0.5, focus));
 return min(1.0, max(body+foot, hands)) * factor;
}



#define ENDER(FC) (((FC.r>FC.g)&&(FC.b>FC.g)&&(FC.b>FC.r))&&(FC.r<0.05&&FC.b<0.05&&FC.g<0.05))
#define NETHER(FC) ((FC.b==FC.g)&&(FC.b*1.5<FC.r))
#define UNWATER(FC,RF) (RF>0.8 &&((FC.b>=FC.g*1.2&&FC.b>=FC.r*2.0) || (FC.r*1.8<FC.g)) )
#define NOOVERWORLD(FC,RF) (ENDER(FC)||NETHER(FC)||UNWATER(FC,RF))

float luminance(vec3 c){
	return dot(c, vec3(0.2126, 0.7152, 0.0722));
}

highp float hash(highp vec2 p){

    p = fract(p * 0.0823565642);
    p += dot(p, p + 10.1936425542);
	
    return fract((p.x + p.y) * p.y);
}

float hash2(vec2 p)
{
	vec3 p3  = fract(vec3(p.xyx) * 0.50235);
    p3 += dot(p3, p3.yzx + 19.1954);
    return fract((p3.x + p3.y) * p3.z);
}

highp float noise( highp vec2 p ){

    highp vec2 i = floor( p*1.0 );
    highp vec2 f = fract( p*1.0 );
	highp vec2 u = f*f*(2.0-1.0*f);

    return mix( mix( hash( i + vec2(0.0,0.0) ), hash( i + vec2(1.0,0.0) ), u.x),mix( hash( i + vec2(0.0,1.0) ), hash( i + vec2(1.0,1.0) ), u.x), u.y);
}

float starMap( in vec2 vSamplePos, float fThreshhold ){
float StarVal = noise( vSamplePos );
if ( StarVal >= fThreshhold ){
StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );
}
else{
StarVal = 0.0;
}
    return StarVal;
}


float starRender( in vec2 vSamplePos, float fThreshhold ){
    float fractX = fract( vSamplePos.x );
    float fractY = fract( vSamplePos.y );
    vec2 floorSample = floor( vSamplePos );    
    float v1 = starMap( floorSample, fThreshhold );
    float v2 = starMap( floorSample + vec2( 0.0, 1.0 ), fThreshhold );
    float v3 = starMap( floorSample + vec2( 1.0, 0.0 ), fThreshhold );
    float v4 = starMap( floorSample + vec2( 1.0, 1.0 ), fThreshhold );

    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )
        			+ v2 * ( 1.0 - fractX ) * fractY
        			+ v3 * fractX * ( 1.0 - fractY )
        			+ v4 * fractX * fractY;
	return StarVal;
}

float cloudmap(highp vec2 pos, float qy){

	highp float d = 1.0;
	highp float nz = 0.0;
	pos *= vec2(6.0, 3.0)*1.5;
	pos -= vec2(1.0, 5.0)-TIME*0.01;
	highp vec2 np = pos;//vec2(pos.y-pos.x, pos.x+pos.y);
	for(float i = 0.0; i < qy; i++){
		nz += noise(np) / (d * (1.0-rain_f*0.3));
		d *= 2.2;
		np *= 2.2;
		np +=  vec2(0.04*TIME,TIME*0.04*pow(d, 0.8));
	}
	
	//float n=clamp((pow(max(nz-0.3,0.0)+0.3,4.0)-0.2)*1.2,0.0,1.0);
	float n= clamp(pow(nz,9.0),0.0,nz*0.8);
	
	return nz;
}

highp float warp(highp vec2 p) {
vec2 q = vec2(cloudmap(vec2(p+TIME*0.003),6.0), noise(p));
vec2 r = vec2( noise(p),cloudmap(vec2(p+TIME*0.003),6.0));
float s = noise(p*vec2(50.0,30.0)+vec2(TIME*0.0001))*noise(p*vec2(60.0,50.0));
float n = noise(p*vec2(70.0,50.0)+vec2(TIME*0.0001))*noise(p*vec2(90.0,50.0));

return cloudmap(p+vec2(s*0.025),CLOUD_DEPTH);
}

highp float reduce_a(highp vec3 pos, highp float size){
mat2 m2 = mat2(0.8,0.6,-0.6,0.8);
pos.xz *= m2/2.0;
highp vec2 pod = pos.xz;
highp float den =1.3*pow(warp(pod*1.3),3.0);
float r = pow(FOG_CONTROL.y,11.0);
return den*size*mix(1.0,0.64,r);
}

highp float reduce_b(highp float den, float alpha){
den *= 1.0;
highp float c = max(den - (1.0 - 0.44),0.0);
den = 1.0 - (pow(0.0015, c));
return den*alpha;
}

vec4 cloudsRender(highp vec3 w_pos,bool is_water){
float cloud1 =clamp(pow(warp(w_pos.xz)-1.0,0.8)*1.8,0.0,1.0);
float cloud1_sh =clamp(pow(warp(w_pos.xz*0.9)-0.9,1.0)*1.5,0.0,1.0)*0.7;

vec4 cloud1_color =mix(vec4(cloud_color.rgb,cloud1),vec4(cloud_sh_color.rgb,cloud1_sh),cloud1_sh);

float cloud2 =0.0;
float cloud2_sh =clamp(pow(warp(w_pos.xz*0.87-vec2(0.2,0.0)*fog_sunset_f)*0.8,1.0)-0.5,0.0,1.0)*(0.4+fog_sunset_f*0.4+fog_night_f*0.4);

for(float n =0.0;n<10.0;n++){
float cloud_p1 =clamp(pow(warp(w_pos.xz*(0.7+n*0.03))*0.5,5.0),0.0,1.0)*(1.3-n*0.1);
float cloud_sh_p =clamp(pow(warp(w_pos.xz*(0.65+n*0.04))*0.3,5.0)-0.05*n,0.0,1.0)*max(0.8-n*0.2,0.0);
cloud2 += cloud_p1;
cloud2_sh += cloud_sh_p*0.1;
}

vec4 cloud2_color=vec4(cloud_color.rgb*min(cloud2+0.6,1.0),cloud2);

vec3 pos =w_pos*3.0;

highp float cloud_sh3,cloud_sh4,sh_m3,sh_m4=0.0;

for(float i = 0.0; i < 5.0; i++){
cloud_sh3 =reduce_b(reduce_a(pos*(0.98-i*0.02-fog_sunset_f*0.01),0.95-i*0.1),0.15+i*0.07);
cloud_sh4 =reduce_b(reduce_a(pos*(0.97-i*0.02-fog_sunset_f*0.01),0.9-i*0.1),0.18+i*0.07);
sh_m3 =max(0.0,max(cloud_sh3,cloud_sh4));
sh_m4 =max(0.0,max(sh_m3,sh_m4));
}

highp float cloud3 = reduce_b(reduce_a(pos,1.0),1.0);

vec4 cloud3_color;
cloud3_color.rgb =mix(cloud_color.rgb*0.8,cloud_sh_color.rgb*vec3(1.0-sh_m4),sh_m4*2.0);
cloud3_color.a =cloud3;

vec4 final_cloud =vec4(0.0);

if(CLOUD==1){
final_cloud =cloud1_color;
}
if(CLOUD==2){
final_cloud =cloud2_color;
}
else if(CLOUD==3){
final_cloud =cloud3_color;
}

if(is_water==true){
final_cloud.rgb =cloud_color.rgb;
}
else{
final_cloud.a -=pow(fog_f*0.8,3.0);
}

if(UNWATER(FOG_COLOR,rain_f)){
final_cloud =vec4(0.0);
}

return final_cloud;
}

highp float highlight(highp vec3 v_pos){
highp vec3 cp =vec3(v_pos.x,v_pos.y,v_pos.z*(1.0+sunset_f*2.0));
#ifdef NORMAL_MAP
cp =vec3(v_pos.x,v_pos.y,v_pos.z*(1.0+sunset_f*5.0));
#endif
highp vec3 np = normalize(cp);
highp float sun = abs(1.0-length(np.yz));
return sun*0.15; 
}

vec3 toneMap(vec3 color, float bright){

	 float A = 2.3f;
	 float B = 0.24f;
	 float C = 2.5f;
	 color *= bright;
	
	return (color * (A * color)) / (color * (C * color) + B);
}

float brightMap(vec3 map){
float bright = (map.r+map.g+map.b)/3.0;
return bright;
}

highp vec4 skyRender(highp vec3 w_pos,bool is_water){

timeFlag();

vec3 c_pos =vec3(w_pos.x,w_pos.y+1.0-fog_sunset_f*0.5,w_pos.z);
highp vec3 np = normalize(c_pos);
highp float sun = abs(1.0-length(np.yz));

cspeColor();

highp float sky_a =length(w_pos);

vec4 sky_color;

if(is_water==true){
sky_a =length(-w_pos)/ FAR_CHUNKS_DISTANCE*1.2;
skytop_color+=0.4;
}

sky_color=mix(skytop_color, sky_far, pow(clamp(sky_a*(2.0-fog_sunset_f*0.2),0.0,1.0),1.2+fog_sunset_f*0.5));
sky_color=mix(sky_color, sfog_color,pow(clamp(sky_a*1.7,0.0,1.0),1.5+fog_sunset_f*0.5));

if(is_water==true){
sky_a =fog_f*0.6;
sky_color=mix(skytop_color*vec4(0.4,0.5,0.7,1.0), sky_far, pow(clamp(sky_a*(3.0-fog_sunset_f*0.2),0.0,1.0),1.0+fog_sunset_f*0.7));
sky_color=mix(sky_color, sfog_color,pow(clamp(sky_a*(1.2+sunset_f*2.0)+highlight(w_pos)*(2.0+sunset_f*3.0),0.0,1.0),1.0+fog_sunset_f*1.4));
}
else{
sky_color +=sun*sfog_color*(1.0-fog_night_f)*7.0;
#ifdef STAR
sky_color =mix(sky_color,stars_color,starRender( w_pos.xz*1000.0, 0.99)*fog_night_f*(1.0-rain_f));
#endif
}

sky_color.rgb =toneMap(sky_color.rgb,0.65);

#ifdef UN_SH_LIGHT
sky_color.rgb +=un_sh_light*0.2;
#endif

if(is_water==true){
sky_color=mix(sky_color, FOG_COLOR,clamp(pow(sky_a,3.0-fog_sunset_f*2.0),0.0,fog_sunset_f));
}
else{
sky_color=mix(sky_color, FOG_COLOR,clamp(pow(sky_a*(1.05),3.0-fog_sunset_f*2.0),0.0,1.0));
}

if(UNWATER(FOG_COLOR,rain_f)){
sky_color =FOG_COLOR;
}

return sky_color;
}

highp float waterMap(highp vec3 pos){
 pos.xz += vec2(TIME*0.8,TIME*0.2);
 highp vec2 np = vec2(pos.z+pos.y, pos.x-pos.z);
 highp float w0 = noise(np);
 return w0;
}


highp float waterMap1(highp vec3 w_pos){
w_pos.xz += vec2(TIME,0.0);
  highp float value = (waterMap(w_pos*vec3(2.0, 1.5, 0.8)+TIME*0.4)*waterMap(w_pos*vec3(2.3, -1.0, -0.8)+TIME*0.6)) * 7.5;
  highp float w1 = (
waterMap(w_pos.zyx*vec3(1.0, 3.0, 2.0)+TIME*0.4+sin(noise(w_pos.xz)) )*(waterMap(w_pos.zyx*vec3(0.6, 4.0, 1.6)+TIME*0.5)) +(waterMap(w_pos.zyx*vec3(0.8, 2.0, 1.2)+TIME*0.5)) 
)* 7.5;
 return w1;
}

vec3 watertep(const int x, const int y, in vec3 w_pos){
	w_pos.xz = (w_pos.xz + vec2(x, y)*0.01);
	return vec3(waterMap1(w_pos));
}

vec3 water_normal(in vec3 w_pos){

	float R = abs(luminance(watertep( 1,0, w_pos)));
	float L = abs(luminance(watertep(-1,0, w_pos)));
	float D = abs(luminance(watertep(0, 1, w_pos)));
	float U = abs(luminance(watertep(0,-1, w_pos)));
				 
	float X = (L-R) * 0.5;
	float Y = (U-D) * 0.5;

	return normalize(vec3(X, Y, 1.0 / 10.0));
}

vec4 reflectRender(vec4 color,vec3 w_pos,vec3 v_pos,bool is_water){

vec3 normal;
vec3 N,L,E;
float fresnel;

if(is_water==true){
normal =water_normal( w_pos);
normal.xyz = normal.rgb * 2.0 - 1.0;
N =normalize(normal.xyz);
L =normalize(vec3(-sunset_f,-1.0+sunset_f,0.0));
E =normalize(abs(v_pos.xyz));
fresnel = pow(clamp(1.0 - (dot(N,-E)), 0.0, 1.0),0.9);
//reflect(E,N)
}
else{
 normal =vec3(1.0);
 N =normalize(normal.xyz);
 L =normalize(vec3(-1.0,0.0,1.0));
}

vec4 sun =vec4(vec3(pow(highlight(v_pos*N)*5.0,5.0)),3.0)*reflect_color;
vec4 clouds =cloudsRender(v_pos*(0.03-clamp(pow(v_pos.y,0.8)*0.001,0.0,0.023))*N,true);
vec4 sky_rex = vec4(mix(skyRender(v_pos*N,true).rgb,clouds.rgb,clouds.a),0.5+fog_f+highlight(v_pos)*3.0);

vec4 diffuse =color;

if(is_water==true){
diffuse =vec4((color.rgb*w_light_color.rgb*vec3(0.6,0.6,0.7))*0.6*clamp(f_sh_f+0.3,0.0,1.0),color.a);
/*
diffuse.rgb =diffuse.rgb*1.6+waterMap1(w_pos)*0.02;
diffuse.a *=0.6+waterMap1(w_pos)*0.05+fog_f;

diffuse =mix(diffuse,sky_rex,clamp(highlight(v_pos)*5.0+1.0*fog_f+clouds.a*0.2,0.0,1.0)*dark_sh_f*side_y_f);
diffuse=mix(diffuse,sun,sun.r*f_sh_f*side_y_f);
*/
diffuse =mix(diffuse,sky_rex,clamp(fresnel*0.5+fog_f*0.5+highlight(v_pos)*5.0,0.0,1.0)*dark_sh_f*side_y_f);
//diffuse=mix(diffuse,sun,sun.r);
}
else{
diffuse =vec4((color.rgb*w_light_color.rgb),color.a);
diffuse =mix(color,sky_rex,clamp(highlight(v_pos)*5.0+fog_f,0.0,1.0)*dark_sh_f*(side_y_f+side_z_f));
diffuse=mix(diffuse,reflect_color,highlight(v_pos)*f_sh_f*side_y_f);
}

//diffuse =mix(diffuse,stars_color,starRender( w_pos.xz*10.0*N.xz, 0.99)*fog_night_f*(1.0-rain_f));

//diffuse.rgb =water_normal( w_pos);

//diffuse+=c_torch_f*lights_color*(1.0-dot(N,L))*0.5;
return diffuse;
}

highp float rippleMap(highp vec3 w_pos){
vec2 p0 = floor(w_pos.xz*2.0);

    vec2 circles = vec2(0.0);
    
    for (float j = -1.0; j <= 1.0; ++j){
        for (float i = -1.0; i <= 1.0; ++i){
			vec2 pi = p0 + vec2(i, j);

            vec2 hsh = pi;

            vec2 p = pi;

            float t = fract(TIME*0.5 + hash2(hsh)-hash(hsh));
            vec2 v = (p - w_pos.xz*2.0)-vec2(fract(hash2(w_pos.xz*2.0)));
            float d = length(v) - (3.0 - fract(hash(hsh)))*t;

            float h = -0.3;
            float d1 = d - h;
            float d2 = d + h;
            float p1 = sin(41.0*d1) * smoothstep(-0.6, -0.3, d1) * smoothstep(0.0, -0.3, d1);
            float p2 = sin(41.0*d2) * smoothstep(-0.6, -0.3, d2) * smoothstep(0.0, -0.3, d2);
            circles += 0.5 * normalize(v) * ((p2 - p1) / (2.0 * h) * (1.0 - t) * (1.0 - t)* (1.0 - t));
            
        }
    }

    vec3 n = vec3(circles, sqrt(1.0 - dot(circles, circles)));
    float ripples =min(3.0*pow(clamp(dot(n, normalize(vec3(1.0, 0.7, 0.5))), 0.0, 1.0), 6.0),0.1);

return ripples;
}

highp vec4 sun_moonRender(vec3 w_pos){

timeFlag();
cspeColor();

highp vec3 p =vec3(w_pos.x,w_pos.y,w_pos.z);

highp float css =1.0-pow(length(w_pos*100.0),1.0);
highp float c0 =1.0-pow(length(w_pos*50.0),fog_night_f*20.0+0.5);
highp float c1 =(1.0-pow(length(p*2.0),0.6*max(pow(FOG_COLOR.r+0.1,5.0),0.15)));

vec4 sun_moon;

sun_moon = vec4(sunmoon_color.rgb,clamp(css,0.0,1.0));
sun_moon =mix(sun_moon,sunmoon_color,clamp(c1,0.0,1.0))*(1.0-fog_sunset_f*0.5);
sun_moon =mix(sun_moon,sunmoon_color,clamp(c0,0.0,1.0))*(1.0-rain_f);

vec4 render_output =sun_moon;

return render_output;
}

void other_worldRender(in vec3 w_pos,in bool is_block){
if(UNWATER(FOG_COLOR,rain_f)){
#ifdef FOG
#ifndef BLEND
f_sh_f=1.0;
#ifdef UN_WATER_L
float un_water_light =clamp(abs(waterMap1(w_pos))*0.2,0.0,1.0)*light_f;
#else
float un_water_light =0.0;
#endif
w_light_color.rgb =mix(uwater_color.rgb*dark_sh_color.rgb,uwater_color.rgb*light_f+un_water_light,clamp(dark_sh_f,0.0,1.0));
w_light_color.rgb =mix(w_light_color.rrr,w_light_color.rgb,clamp(fog_f*5.0,0.0,1.0));
lights_color=unwater_lights_color;
sfog_color =FOG_COLOR;
#endif
#endif
}
if(ENDER(FOG_COLOR)){
f_sh_f=1.0;
w_light_color.rgb =ender_color.rgb;
lights_color=ender_lights_color-side_y_f*vec4(0.8,0.0,0.0,0.0);
sfog_color =FOG_COLOR;
deep_fog_color.rgb =vec3(0.1,0.1,0.2);
}
if(NETHER(FOG_COLOR)){
f_sh_f=1.0;
x_sh_f=0.15;
w_light_color.rgb =nether_color.rgb;
lights_color=nether_lights_color;
dark_sh_color.rgb*=2.0;
sfog_color =FOG_COLOR;
deep_fog_color.rgb =vec3(1.0,0.5,0.0);
fog_f*=0.5;
}
}