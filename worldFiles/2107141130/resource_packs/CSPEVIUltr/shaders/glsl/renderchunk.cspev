// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

#include "vertexVersionCentroid.h"
#if __VERSION__ >= 300
	#ifndef BYPASS_PIXEL_SHADER
		_centroid out vec2 uv0;
		_centroid out vec2 uv1;
	#endif
#else
	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 uv0;
		varying vec2 uv1;
	#endif
#endif

#ifndef BYPASS_PIXEL_SHADER
	varying vec4 color;
#endif

varying highp vec3 w_pos;
varying highp vec3 v_pos;

#ifdef FOG
	varying vec4 fogColor;
#endif

#include "uniformWorldConstants.h"
#include "uniformPerFrameConstants.h"
#include "uniformShaderConstants.h"
#include "uniformRenderChunkConstants.h"

attribute POS4 POSITION;
attribute vec4 COLOR;
attribute vec2 TEXCOORD_0;
attribute vec2 TEXCOORD_1;

const float rA = 1.0;
const float rB = 1.0;
const vec3 UNIT_Y = vec3(0,1,0);
const float DIST_DESATURATION = 56.0 / 255.0; //WARNING this value is also hardcoded in the water color, don'tchange

#include "cspe_custom/cspe_option.txt"

void main()
{
    POS4 worldPos;
#ifdef AS_ENTITY_RENDERER
		POS4 pos = WORLDVIEWPROJ * POSITION;
		worldPos = pos;
#else
    worldPos.xyz = (POSITION.xyz * CHUNK_ORIGIN_AND_SCALE.w) + CHUNK_ORIGIN_AND_SCALE.xyz;
    worldPos.w = 1.0;

    // Transform to view space before projection instead of all at once to avoid floating point errors
    // Not required for entities because they are already offset by camera translation before rendering
    // World position here is calculated above and can get huge
    POS4 pos = WORLDVIEW * worldPos;
    pos = PROJ * pos;
#endif
    gl_Position = pos;

v_pos = worldPos.xyz;
w_pos = POSITION.xyz;

float rain_f =clamp((1.0-pow(FOG_CONTROL.y+0.1,5.0))*2.0,0.0,1.0);

highp vec3 wav_pos = vec3(0.0);

vec2 t_pos =floor(vec2(TEXCOORD_0.x * 32.0, TEXCOORD_0.y * 32.0));

#ifndef BYPASS_PIXEL_SHADER
    uv0 = TEXCOORD_0;
    uv1 = TEXCOORD_1;
	color = COLOR;
#endif

#ifdef ALPHA_TEST

#ifdef PLANT_WAVE

float wind =max(sin((w_pos.x+w_pos.z)*0.5+TIME*2.0),0.3*rain_f)*TEXCOORD_1.y*(1.0+rain_f*1.5);

wav_pos.x = (sin(TIME*4.0 + w_pos.x*1.2)+sin(TIME*3.0 + w_pos.x*0.8) + sin(TIME*6.2 + w_pos.z*2.5))*0.04;
wav_pos.x *= pow(1.0-(TEXCOORD_0.y * 32.0-t_pos.y),2.0)*wind;

if((color.r==color.g&&color.g==color.b)||(t_pos.y==15.0)||(color.r>color.g*2.0)){
wav_pos = vec3(0.0);
}
else if((color.r!=color.g&&color.g!=color.b)){
wav_pos *= 3.0;

if(t_pos.y==8.0&&t_pos.x<=23.0){ //grass bot
wav_pos.x = (sin(TIME*4.0 + w_pos.x*1.2)+sin(TIME*3.0 + w_pos.x*0.8) + sin(TIME*6.2 + w_pos.z*2.5))*0.04;
wav_pos *= wind*1.68;
}

if(uv1.y>=0.0&&color.a==0.0){//leaves
wav_pos.x = (sin(TIME*1.1+ w_pos.x*1.4)+sin(TIME*2.1+ w_pos.x*1.51) - sin(TIME*5.2 - w_pos.z*2.0))*0.017;
wav_pos.y = (sin(TIME*4.3 + w_pos.x*4.01)+sin(TIME*3.9+ w_pos.x*3.5) + sin(TIME*6.2 + w_pos.z*5.0))*0.005;
wav_pos*=wind*2.0;
}
else if(t_pos.y==20.0&&t_pos.x<=11.0){
wav_pos.x = (sin(TIME*1.1+ w_pos.x*1.4)+sin(TIME*2.1+ w_pos.x*1.51) - sin(TIME*5.2 - w_pos.z*2.0))*0.017;
wav_pos.y = (sin(TIME*4.3 + w_pos.x*4.01)+sin(TIME*3.9+ w_pos.x*3.5) + sin(TIME*6.2 + w_pos.z*5.0))*0.005;
wav_pos*=wind;
}

}
else{
wav_pos = vec3(0.0);
}
#endif

gl_Position.xyz +=wav_pos.xyz;

#endif

///// find distance from the camera

#if defined(FOG) || defined(BLEND)
	#ifdef FANCY
		vec3 relPos = -worldPos.xyz;
		float cameraDepth = length(relPos);
	#else
		float cameraDepth = pos.z;
	#endif
#endif

///// apply fog

#ifdef FOG
	float len = cameraDepth / RENDER_DISTANCE;
	#ifdef ALLOW_FADE
		len += RENDER_CHUNK_FOG_ALPHA;
	#endif

    fogColor.rgb = FOG_COLOR.rgb;
	fogColor.a = clamp((len - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);
#endif

///// blended layer (mostly water) magic


#ifndef BYPASS_PIXEL_SHADER
	#ifndef FOG
		// If the FOG_COLOR isn't used, the reflection on NVN fails to compute the correct size of the constant buffer as the uniform will also be gone from the reflection data
		color.rgb += FOG_COLOR.rgb * 0.000001;
	#endif
#endif
}
