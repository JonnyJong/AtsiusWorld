// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

#include "fragmentVersionCentroid.h"

#if __VERSION__ >= 300
	#ifndef BYPASS_PIXEL_SHADER
		#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
			_centroid in highp vec2 uv0;
			_centroid in highp vec2 uv1;
		#else
			_centroid in vec2 uv0;
			_centroid in vec2 uv1;
		#endif
	#endif
#else
	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 uv0;
		varying vec2 uv1;
	#endif
#endif

varying vec4 color;

varying highp vec3 w_pos;
varying highp vec3 v_pos;

#ifdef FOG
varying vec4 fogColor;
#endif

#include "uniformShaderConstants.h"
#include "util.h"

LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;
LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;

#include "function_lib.cspe"

#define OFFSET_X 1
#define OFFSET_Y 1

vec3 texsample(const int x, const int y, in vec2 uv){
	uv = (uv + vec2(x, y)*0.001);
	return texture(TEXTURE_0, uv).xyz;
}

vec3 normal_map(in vec2 fragCoord){
	float R = abs(luminance(texsample( OFFSET_X,0, fragCoord)));
	float L = abs(luminance(texsample(-OFFSET_X,0, fragCoord)));
	float D = abs(luminance(texsample(0, OFFSET_Y, fragCoord)));
	float U = abs(luminance(texsample(0,-OFFSET_Y, fragCoord)));
				 
	float X = (L-R) * 0.5;
	float Y = (U-D) * 0.5;

	return normalize(vec3(X, Y, 1.0 / NORMAL_MAP_DEPTH));
}

void main()
{
vec4 tex = texture2D( TEXTURE_0, uv0 );

light_f = smoothstep(0.0,1.0,texture2D( TEXTURE_1, vec2(0.0,1.0)).r);

fog_f =length(-v_pos)/ FAR_CHUNKS_DISTANCE;

timeFlag();

side_f=normalize(cross(dFdx(w_pos),dFdy(w_pos)));

side_top_f =clamp(side_f.y,0.0,1.0);
side_bot_f =clamp(-side_f.y,0.0,1.0);
side_y_f =clamp(abs(side_f.y),0.0,1.0);
side_x_f =clamp(abs(side_f.x),0.0,1.0);
side_z_f =clamp(abs(side_f.z),0.0,1.0);
side_xz_f =clamp(side_x_f+side_z_f,0.0,1.0);

cspeColor();

f_sh_f =0.125;
x_sh_f =0.31;

dark_sh_f =pow(uv1.y,1.0);

#ifdef SEASONS
f_sh_f =0.13;
x_sh_f =color.a*3.0;
w_light_color*=1.25;
#endif

float c_torch_f =pow(uv1.x,5.0)+uv1.x*side_xz_f*0.1;

float tgrass_sh_f =clamp(side_f.x*side_f.z,0.0,1.0);

float player_sh_f =clamp(playerShadowSet(w_pos,v_pos),0.0,1.0);

#ifdef BYPASS_PIXEL_SHADER
	gl_FragColor = vec4(0, 0, 0, 0);
	return;
#else 

#if USE_TEXEL_AA
	vec4 diffuse = texture2D_AA(TEXTURE_0, uv0);
#else
	vec4 diffuse = texture2D(TEXTURE_0, uv0);
#endif
	
#ifdef SEASONS_FAR
	diffuse.a = 1.0;
#endif

#if USE_ALPHA_TEST
	#ifdef ALPHA_TO_COVERAGE
	#define ALPHA_THRESHOLD 0.05
	#else
	#define ALPHA_THRESHOLD 0.5
	#endif
	if(diffuse.a < ALPHA_THRESHOLD)
		discard;
#endif
	
vec4 inColor = color;

float bright_diffuse =brightMap(diffuse.rgb);
float bright_color =brightMap(color.rgb);

#if defined(BLEND)
	diffuse.a *= inColor.a;
#endif

#if !defined(ALWAYS_LIT)
	//diffuse *= texture2D( TEXTURE_1, uv1 );
#endif

#ifndef SEASONS
	#if !USE_ALPHA_TEST && !defined(BLEND)
		diffuse.a = inColor.a;
	#endif
	
if(color.g * 1.9 >= color.r + color.b){
diffuse.rgb *= mix(pow(inColor.rgb,vec3(0.5)),inColor.rgb,clamp(pow(color.g+0.4,3.0),0.0,1.0));
}
else{
diffuse.rgb *= pow(inColor.rgb,vec3(0.2));
}

#else
	vec2 uv = inColor.xy;
	diffuse.rgb *= mix(vec3(1.0,1.0,1.0), texture2D( TEXTURE_2, uv).rgb*2.0, inColor.b);
	diffuse.rgb *= inColor.aaa;
	diffuse.a = 1.0;
#endif

other_worldRender(w_pos,true);

f_sh_f =pow(clamp((uv1.y+f_sh_f),(0.0),(1.0)),(100.0));
x_sh_f =pow(clamp((color.g+1.5*(color.g-color.b)+x_sh_f),(0.0),(1.0)),(28.0-(1.0-(c_torch_f+f_sh_f))*25.0));

if(uv1.y>=0.0&&color.a==0.0){
x_sh_f = (min(pow((color.g*2.3+color.r*0.1+color.b*1.2)*0.7,10.0)+sunset_f*0.54,1.0));
w_light_color*=1.2;
} 

vec4 sh =vec4(f_sh_f*x_sh_f);

#ifdef PLAYER_SHADOW
sh =clamp(sh-player_sh_f,vec4(0.0),vec4(1.0));
#endif

sh =clamp(sh-side_y_f*sunset_f*0.5-(side_x_f-tgrass_sh_f*2.0),vec4(0.0),vec4(1.0));
sh =mix(sh,sky_far*(0.3-side_bot_f*0.2)+shadow_color,clamp(dark_sh_f*(1.0-sh.r),0.0,1.0));

#ifdef BLOCK_HIGHLIGHT
vec3 block_highlight =highlight(v_pos)*reflect_color.rgb*(sh.r+sunset_f*side_y_f*f_sh_f);
#else
vec3 block_highlight =vec3(0.0);
#endif

#ifdef NORMAL_MAP
block_highlight =highlight(v_pos)*reflect_color.rgb*(side_y_f*f_sh_f);
vec3 normal =normal_map(uv0);
float highlight_map =pow(brightMap(diffuse.rgb)+0.6,5.0);
normal.xyz = normal.rgb * 2.0 - 1.0;
vec3 N =normalize(normal.xyz);
vec3 L =normalize(vec3(-sunset_f,-1.0+sunset_f,0.0));
vec3 E =normalize(v_pos);
vec3 w_nor_light_color = sh.rgb*max(w_light_color.rgb*dot(N, L)*1.6,mix(dark_sh_color.rgb,sky_far.rgb*0.25+shadow_color.rgb,clamp(dark_sh_f,0.0,1.0)));
vec3 torch_nor_light_color =c_torch_f*lights_color.rgb*clamp(c_torch_f*3.0,0.0,1.0);
float reflect_nor_reduce_f =1.2-brightMap(w_nor_light_color.rgb);
#endif

w_light_color =max(sh*w_light_color,dark_sh_color);

float reflect_reduce_f =1.0-brightMap(w_light_color.rgb);

vec3 torch_light_color =c_torch_f*lights_color.rgb*clamp(x_sh_f+c_torch_f*3.0,0.0,1.0);

diffuse.rgb =mix(diffuse.rgb,vec3(bright_diffuse), clamp(sh.r*night_f*0.7-c_torch_f*3.0,0.0,1.0));

#ifdef NORMAL_MAP
diffuse.rgb *=w_nor_light_color+(torch_nor_light_color)*reflect_nor_reduce_f+highlight_map*block_highlight;
#else
diffuse.rgb *=w_light_color.rgb+(torch_light_color)*reflect_reduce_f+block_highlight;
diffuse.rgb +=w_light_color.rgb*w_light_color.a+c_torch_f*lights_color.rgb*0.05;
#endif

diffuse.rgb =toneMap(diffuse.rgb,0.65);

#ifdef NEW_FOG
diffuse.rgb = mix(diffuse.rgb,mix(deep_fog_color.rgb,mix(FOG_COLOR.rgb*deep_fog_color.rgb,FOG_COLOR.rgb*sfog_color.rgb*vec3(1.0,0.9,1.0)+highlight(v_pos)*2.0,sh.r),uv1.y),fog_f*(0.4-sh.r*0.1));
#endif

#ifdef BLEND
if((color.a > 0.6&&color.b>color.r*1.1)||(color.a > 0.95&&bright_color<0.4)) {
water_f =1.0;
}
else{
water_f =0.0;
if(tex.a<1.0&&tex.a>0.3){
#ifdef GLASS_REFLECT
diffuse =reflectRender(vec4(diffuse.rgb,pow(diffuse.a,0.2)*0.7),w_pos,vec3(v_pos.x,-v_pos.y,-v_pos.z),false);
#endif
}
}
#endif

#ifdef FOG
if((color.r*1.5<color.b&&color.b>color.g*1.2)){
water_f =1.0;
#ifdef SEASONS
water_f =0.0;
#endif
}
else{
water_f =0.0;
}
#endif

if(water_f==1.0){

f_sh_f =pow(clamp((uv1.y+0.09),(0.0),(1.0)),(80.0));

#ifdef ORIGIN_WATER_COLOR
#else
inColor.rgb =water_color.rgb;
#endif

#ifdef WATER_EFFECT
diffuse =reflectRender(inColor,w_pos,vec3(v_pos.x,-v_pos.y,-v_pos.z),true)*water_color;
#else
diffuse =vec4((inColor.rgb*w_light_color.rgb)*0.4*clamp(f_sh_f+0.3,0.0,1.0),color.a)*water_color;
#endif
}

//diffuse +=(rippleMap(w_pos)*3.0)*sh.r*side_y_f*0.5*rain_f;

#ifdef FOG
#ifdef ORIGIN_FOG
if(NOOVERWORLD(FOG_COLOR,rain_f)){
}
else{
sfog_color.rgb*=0.8+highlight(v_pos);
}
	diffuse.rgb = mix( diffuse.rgb, sfog_color.rgb, fogColor.a );
#endif
#endif
/*
#ifndef FANCY
if(fog_f<0.05)
discard;
#endif
*/
	gl_FragColor = diffuse;
	
#endif // BYPASS_PIXEL_SHADER
}
